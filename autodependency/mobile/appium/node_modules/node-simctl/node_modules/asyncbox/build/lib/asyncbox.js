'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _core = require('babel-runtime/core-js')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

_core.Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Q = require('q');

var _Q2 = _interopRequireWildcard(_Q);

var _mapify = require('es6-mapify');

require('source-map-support').install();

function sleep(ms) {
  var nodeSetTimeout;
  return _regeneratorRuntime.async(function sleep$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        nodeSetTimeout = function nodeSetTimeout(ms, cb) {
          return setTimeout(cb, ms);
        };

        context$1$0.next = 3;
        return _Q2['default'].nfcall(nodeSetTimeout, ms);

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function retry(times, fn) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var tries, done, res;
  return _regeneratorRuntime.async(function retry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        tries = 0;
        done = false;
        res = null;

      case 3:
        if (!(!done && tries < times)) {
          context$1$0.next = 18;
          break;
        }

        tries++;
        context$1$0.prev = 5;
        context$1$0.next = 8;
        return fn.apply(undefined, args);

      case 8:
        res = context$1$0.sent;

        done = true;
        context$1$0.next = 16;
        break;

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](5);

        if (!(tries >= times)) {
          context$1$0.next = 16;
          break;
        }

        throw context$1$0.t0;

      case 16:
        context$1$0.next = 3;
        break;

      case 18:
        return context$1$0.abrupt('return', res);

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 12]]);
}

function retryInterval(times, sleepMs, fn) {
  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  var wrapped;
  return _regeneratorRuntime.async(function retryInterval$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        wrapped = function wrapped() {
          var res;
          return _regeneratorRuntime.async(function wrapped$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                res = undefined;
                context$2$0.prev = 1;
                context$2$0.next = 4;
                return fn.apply(undefined, args);

              case 4:
                res = context$2$0.sent;
                context$2$0.next = 12;
                break;

              case 7:
                context$2$0.prev = 7;
                context$2$0.t1 = context$2$0['catch'](1);
                context$2$0.next = 11;
                return sleep(sleepMs);

              case 11:
                throw context$2$0.t1;

              case 12:
                return context$2$0.abrupt('return', res);

              case 13:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[1, 7]]);
        };

        return context$1$0.abrupt('return', retry(times, wrapped));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function parallel(promises) {
  var done, results, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, p;

  return _regeneratorRuntime.async(function parallel$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (promises instanceof Array) {
          context$1$0.next = 2;
          break;
        }

        throw new Error('Must parallelize a list of promises');

      case 2:
        if (!(promises.length < 1)) {
          context$1$0.next = 4;
          break;
        }

        throw new Error('List of promises was empty');

      case 4:
        done = _Q2['default'].defer();
        results = [];
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 9;
        _iterator = _core.getIterator(promises);

      case 11:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 19;
          break;
        }

        p = _step.value;

        if (!(!p.then || !p['catch'])) {
          context$1$0.next = 15;
          break;
        }

        throw new Error('Tried to parallelize a non-promise');

      case 15:
        p.then(function (res) {
          results.push(res);
          if (results.length === promises.length) {
            done.resolve(results);
          }
        }, function (err) {
          done.reject(err);
        });

      case 16:
        _iteratorNormalCompletion = true;
        context$1$0.next = 11;
        break;

      case 19:
        context$1$0.next = 25;
        break;

      case 21:
        context$1$0.prev = 21;
        context$1$0.t2 = context$1$0['catch'](9);
        _didIteratorError = true;
        _iteratorError = context$1$0.t2;

      case 25:
        context$1$0.prev = 25;
        context$1$0.prev = 26;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 28:
        context$1$0.prev = 28;

        if (!_didIteratorError) {
          context$1$0.next = 31;
          break;
        }

        throw _iteratorError;

      case 31:
        return context$1$0.finish(28);

      case 32:
        return context$1$0.finish(25);

      case 33:
        return context$1$0.abrupt('return', done.promise);

      case 34:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 21, 25, 33], [26,, 28, 32]]);
}

function nodeify(promisey, cb) {
  promisey.then(function (res) {
    cb(null, res);
  }, cb);
}

function nodeifyAll(promiseyMap) {
  var cbMap = {};
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop = function () {
      _step2$value = _slicedToArray(_step2.value, 2);
      var name = _step2$value[0];
      var fn = _step2$value[1];

      /*jshint -W083 */
      cbMap[name] = function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var _cb = args.slice(-1)[0];
        args = args.slice(0, -1);
        nodeify(fn.apply(undefined, args), _cb);
      };
    };

    for (var _iterator2 = _core.getIterator(_mapify.mapify(promiseyMap)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value;

      _loop();
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
        _iterator2['return']();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return cbMap;
}

function asyncify(fn) {
  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  fn.call.apply(fn, [null].concat(args)).then(function () {}, function (err) {
    console.error(err.stack);
  });
}

exports.sleep = sleep;
exports.retry = retry;
exports.nodeify = nodeify;
exports.nodeifyAll = nodeifyAll;
exports.retryInterval = retryInterval;
exports.asyncify = asyncify;
exports.parallel = parallel;

/*jshint -W083 */
//# sourceMappingURL=data:application/json;base64,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Q29udGVudCI6WyJyZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQnKS5pbnN0YWxsKCk7XG5cbmltcG9ydCBRIGZyb20gJ3EnO1xuaW1wb3J0IHsgbWFwaWZ5IH0gZnJvbSAnZXM2LW1hcGlmeSc7XG5cbmFzeW5jIGZ1bmN0aW9uIHNsZWVwIChtcykge1xuICBsZXQgbm9kZVNldFRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIGNiKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoY2IsIG1zKTtcbiAgfTtcbiAgcmV0dXJuIGF3YWl0IFEubmZjYWxsKG5vZGVTZXRUaW1lb3V0LCBtcyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJldHJ5ICh0aW1lcywgZm4sIC4uLmFyZ3MpIHtcbiAgbGV0IHRyaWVzID0gMDtcbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgbGV0IHJlcyA9IG51bGw7XG4gIHdoaWxlICghZG9uZSAmJiB0cmllcyA8IHRpbWVzKSB7XG4gICAgdHJpZXMrKztcbiAgICB0cnkge1xuICAgICAgcmVzID0gYXdhaXQgZm4oLi4uYXJncyk7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cmllcyA+PSB0aW1lcykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJldHJ5SW50ZXJ2YWwgKHRpbWVzLCBzbGVlcE1zLCBmbiwgLi4uYXJncykge1xuICBsZXQgd3JhcHBlZCA9IGFzeW5jICgpID0+IHtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhd2FpdCBzbGVlcChzbGVlcE1zKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJldHVybiByZXRyeSh0aW1lcywgd3JhcHBlZCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcmFsbGVsIChwcm9taXNlcykge1xuICBpZiAoIShwcm9taXNlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcGFyYWxsZWxpemUgYSBsaXN0IG9mIHByb21pc2VzXCIpO1xuICB9XG4gIGlmIChwcm9taXNlcy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTGlzdCBvZiBwcm9taXNlcyB3YXMgZW1wdHlcIik7XG4gIH1cbiAgbGV0IGRvbmUgPSBRLmRlZmVyKCk7XG4gIGxldCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IHAgb2YgcHJvbWlzZXMpIHtcbiAgICAvKmpzaGludCAtVzA4MyAqL1xuICAgIGlmICghcC50aGVuIHx8ICFwLmNhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBwYXJhbGxlbGl6ZSBhIG5vbi1wcm9taXNlXCIpO1xuICAgIH1cbiAgICBwLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgcmVzdWx0cy5wdXNoKHJlcyk7XG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICBkb25lLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgZG9uZS5yZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZG9uZS5wcm9taXNlO1xufVxuXG5mdW5jdGlvbiBub2RlaWZ5IChwcm9taXNleSwgY2IpIHtcbiAgcHJvbWlzZXkudGhlbihyZXMgPT4geyBjYihudWxsLCByZXMpOyB9LCBjYik7XG59XG5cbmZ1bmN0aW9uIG5vZGVpZnlBbGwgKHByb21pc2V5TWFwKSB7XG4gIGxldCBjYk1hcCA9IHt9O1xuICBmb3IgKGxldCBbbmFtZSwgZm5dIG9mIG1hcGlmeShwcm9taXNleU1hcCkpIHtcbiAgICAvKmpzaGludCAtVzA4MyAqL1xuICAgIGNiTWFwW25hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGxldCBfY2IgPSBhcmdzLnNsaWNlKC0xKVswXTtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDAsIC0xKTtcbiAgICAgIG5vZGVpZnkoZm4oLi4uYXJncyksIF9jYik7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2JNYXA7XG59XG5cbmZ1bmN0aW9uIGFzeW5jaWZ5IChmbiwgLi4uYXJncykge1xuICBmbi5jYWxsKG51bGwsIC4uLmFyZ3MpLnRoZW4oKCkgPT4ge30sIChlcnIpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBzbGVlcCwgcmV0cnksIG5vZGVpZnksIG5vZGVpZnlBbGwsIHJldHJ5SW50ZXJ2YWwsIGFzeW5jaWZ5LCBwYXJhbGxlbCB9O1xuIl19