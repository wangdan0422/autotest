'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _core = require('babel-runtime/core-js')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

_core.Object.defineProperty(exports, '__esModule', {
  value: true
});

var _npmlog = require('npmlog');

var _npmlog2 = _interopRequireWildcard(_npmlog);

var _support = require('appium-support');

var _support2 = _interopRequireWildcard(_support);

var _fs = require('fs');

var _fs2 = _interopRequireWildcard(_fs);

var _denodeify = require('denodeify');

var _denodeify2 = _interopRequireWildcard(_denodeify);

var _path = require('path');

var _path2 = _interopRequireWildcard(_path);

var _retry = require('asyncbox');

var _import = require('lodash');

var _import2 = _interopRequireWildcard(_import);

var _plist = require('plist');

var _plist2 = _interopRequireWildcard(_plist);

var exec = _support2['default'].core.exec;
var util = _support2['default'].util;
var fileExists = _support2['default'].util.fileExists;
var escapeSpace = _support2['default'].util.escapeSpace;
var readSymlink = _denodeify2['default'](_fs2['default'].readlink);
var env = process.env;

var XCODE_SELECT_TIMEOUT = 3000;
var XCODE_SUBDIR = '/Contents/Developer';
var DEFAULT_NUMBER_OF_RETRIES = 3;

var log = process.env.GLOBAL_NPMLOG ? global.log : _npmlog2['default'];

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

function getPathFromSymlink(failMessage) {
  var symlinkPath, legacySymlinkPath, xcodePath, customPath, mesg, msg;
  return _regeneratorRuntime.async(function getPathFromSymlink$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // Node's invocation of xcode-select sometimes flakes and returns an empty string.
        // Not clear why. As a workaround, Appium can reliably deduce the version in use by checking
        // the locations xcode-select uses to store the selected version's path. This should be 100%
        // reliable so long as the link locations remain the same. However, since we're relying on
        // hardcoded paths, this approach will break the next time Apple changes the symlink location.
        log.warn('Finding XcodePath by symlink because ' + failMessage);

        symlinkPath = '/var/db/xcode_select_link';
        legacySymlinkPath = '/usr/share/xcode-select/xcode_dir_link';
        xcodePath = null;

        if (!util.hasContent(env.DEVELOPER_DIR)) {
          context$1$0.next = 17;
          break;
        }

        customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;
        context$1$0.next = 8;
        return fileExists(customPath);

      case 8:
        if (!context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        xcodePath = customPath;
        context$1$0.next = 15;
        break;

      case 12:
        mesg = 'Could not find path to Xcode, environment variable ' + ('DEVELOPER_DIR set to: ' + env.DEVELOPER_DIR + ' ') + 'but no Xcode found';

        log.warn(mesg);
        throw new Error(mesg);

      case 15:
        context$1$0.next = 27;
        break;

      case 17:
        context$1$0.next = 19;
        return fileExists(symlinkPath);

      case 19:
        if (!context$1$0.sent) {
          context$1$0.next = 23;
          break;
        }

        xcodePath = readSymlink(symlinkPath);
        context$1$0.next = 27;
        break;

      case 23:
        context$1$0.next = 25;
        return fileExists(legacySymlinkPath);

      case 25:
        if (!context$1$0.sent) {
          context$1$0.next = 27;
          break;
        }

        xcodePath = readSymlink(legacySymlinkPath);

      case 27:
        if (!xcodePath) {
          context$1$0.next = 29;
          break;
        }

        return context$1$0.abrupt('return', xcodePath.replace(new RegExp('/$'), '').trim());

      case 29:
        msg = 'Could not find path to Xcode by symlinks located in ' + symlinkPath + ', or ' + legacySymlinkPath;

        log.warn(msg);
        throw new Error(msg);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getPathFromXcodeSelect() {
  var _ref, _ref2, stdout, xcodeFolderPath, msg;

  return _regeneratorRuntime.async(function getPathFromXcodeSelect$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return exec('xcode-select --print-path', { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT });

      case 2:
        _ref = context$1$0.sent;
        _ref2 = _slicedToArray(_ref, 1);
        stdout = _ref2[0];
        xcodeFolderPath = stdout.replace(new RegExp('/$'), '').trim();

        if (util.hasContent(xcodeFolderPath)) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('xcode-select returned an empty string');

      case 8:
        context$1$0.next = 10;
        return fileExists(xcodeFolderPath);

      case 10:
        if (!context$1$0.sent) {
          context$1$0.next = 14;
          break;
        }

        return context$1$0.abrupt('return', xcodeFolderPath);

      case 14:
        msg = 'xcode-select could not find xcode. Path: ' + xcodeFolderPath + ' does not exist.';

        log.error(msg);
        throw new Error(msg);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getPath = _import2['default'].memoize(function () {

  // first we try using xcode-select to find the path
  // then we try using the symlinks that Apple has by default

  return getPathFromXcodeSelect()['catch'](getPathFromSymlink);
});

function getVersionWithoutRetry() {
  var xcodePath, plistPath, cmd, _ref3, _ref32, stdout, versionPattern, match;

  return _regeneratorRuntime.async(function getVersionWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return getPath();

      case 2:
        xcodePath = context$1$0.sent;
        plistPath = _path2['default'].resolve(xcodePath, '..', 'Info.plist');
        context$1$0.next = 6;
        return fileExists(plistPath);

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Could not get Xcode version. ' + plistPath + ' does not exist on disk.');

      case 8:
        cmd = '/usr/libexec/PlistBuddy -c \'Print CFBundleShortVersionString\' ' + escapeSpace(plistPath);
        context$1$0.next = 11;
        return exec(cmd, { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT });

      case 11:
        _ref3 = context$1$0.sent;
        _ref32 = _slicedToArray(_ref3, 1);
        stdout = _ref32[0];
        versionPattern = /\d\.\d\.*\d*/;
        match = stdout.match(versionPattern);

        if (!(match === null || !util.hasContent(match[0]))) {
          context$1$0.next = 18;
          break;
        }

        throw new Error('Could not parse Xcode version. xcodebuild output was: ' + stdout);

      case 18:
        return context$1$0.abrupt('return', match[0]);

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getVersion = _import2['default'].memoize(function () {
  var retries = arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return _retry.retry(retries, getVersionWithoutRetry);
});

function getAutomationTraceTemplatePathWithoutRetry() {
  var xcodePath, extensions, pathPrefix, pathSuffix, automationTraceTemplatePaths, msg;
  return _regeneratorRuntime.async(function getAutomationTraceTemplatePathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return getPath();

      case 2:
        xcodePath = context$1$0.sent;
        extensions = ['xrplugin', 'bundle'];
        pathPrefix = _path2['default'].resolve(xcodePath, '../Applications/Instruments.app/Contents/PlugIns');
        pathSuffix = 'Contents/Resources/Automation.tracetemplate';
        automationTraceTemplatePaths = [_path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[0], pathSuffix), _path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[1], pathSuffix)];
        context$1$0.next = 9;
        return fileExists(automationTraceTemplatePaths[0]);

      case 9:
        if (!context$1$0.sent) {
          context$1$0.next = 11;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[0]);

      case 11:
        context$1$0.next = 13;
        return fileExists(automationTraceTemplatePaths[1]);

      case 13:
        if (!context$1$0.sent) {
          context$1$0.next = 15;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[1]);

      case 15:
        msg = 'Could not find Automation.tracetemplate in any of the following' + ('locations ' + automationTraceTemplatePaths.toString());

        log.error(msg);
        throw new Error(msg);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getAutomationTraceTemplatePath = _import2['default'].memoize(function () {
  var retries = arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return _retry.retry(retries, getAutomationTraceTemplatePathWithoutRetry);
});

function getMaxIOSSDKWithoutRetry() {
  var version, cmd, _ref4, _ref42, stdout, sdkVersion, match;

  return _regeneratorRuntime.async(function getMaxIOSSDKWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return getVersion();

      case 2:
        version = context$1$0.sent;

        if (!(version[0] === '4')) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', '6.1');

      case 5:
        cmd = 'xcrun --sdk iphonesimulator --show-sdk-version';
        context$1$0.next = 8;
        return exec(cmd, { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT });

      case 8:
        _ref4 = context$1$0.sent;
        _ref42 = _slicedToArray(_ref4, 1);
        stdout = _ref42[0];
        sdkVersion = stdout.trim();
        match = /\d.\d/.exec(stdout);

        if (match) {
          context$1$0.next = 15;
          break;
        }

        throw new Error('xcrun returned a non-numeric iOS SDK version: ' + sdkVersion);

      case 15:
        return context$1$0.abrupt('return', sdkVersion);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getMaxIOSSDK = _import2['default'].memoize(function () {
  var retries = arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return _retry.retry(retries, getMaxIOSSDKWithoutRetry);
});

function getConnectedDevices() {
  var _ref5, _ref52, stdout, plistContent, devicesFound, entriesToSearch, currentEntry, deviceInfo;

  return _regeneratorRuntime.async(function getConnectedDevices$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return exec('/usr/sbin/system_profiler -xml SPUSBDataType', { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT });

      case 2:
        _ref5 = context$1$0.sent;
        _ref52 = _slicedToArray(_ref5, 1);
        stdout = _ref52[0];
        plistContent = _plist2['default'].parse(stdout);
        devicesFound = [];
        entriesToSearch = [plistContent[0]];

        while (entriesToSearch.length > 0) {
          currentEntry = entriesToSearch.pop();

          if (currentEntry instanceof Array) {
            entriesToSearch = entriesToSearch.concat(currentEntry);
          } else if (currentEntry._name && currentEntry._name.substring(0, 4) === 'iPad' || currentEntry._name && currentEntry._name.substring(0, 6) === 'iPhone') {
            deviceInfo = {
              name: currentEntry._name,
              udid: currentEntry.serial_num,
              productId: currentEntry.product_id,
              deviceVersion: currentEntry.bcd_device
            };

            devicesFound.push(deviceInfo);
          } else if (currentEntry._items) {
            entriesToSearch = entriesToSearch.concat(currentEntry._items);
          }
        }
        return context$1$0.abrupt('return', devicesFound);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function clearInternalCache() {

  // memoized functions
  var memoized = [getPath, getVersion, getAutomationTraceTemplatePath, getMaxIOSSDK];

  memoized.forEach(function (f) {
    if (f.cache) {
      f.cache = new _import2['default'].memoize.Cache();
    }
  });
}

exports.getPath = getPath;
exports.getVersion = getVersion;
exports.getAutomationTraceTemplatePath = getAutomationTraceTemplatePath;
exports.getMaxIOSSDK = getMaxIOSSDK;
exports.getAutomationTraceTemplatePathWithoutRetry = getAutomationTraceTemplatePathWithoutRetry;
exports.getMaxIOSSDKWithoutRetry = getMaxIOSSDKWithoutRetry;
exports.getConnectedDevices = getConnectedDevices;
exports.clearInternalCache = clearInternalCache;
//  Xcode < 5.x

// xcode-select allows users to override its settings with the DEVELOPER_DIR env var,
// so check that first

// We should only get here is we failed to capture xcode-select's stdout and our
// other checks failed. Either Apple has moved the symlink to a new location or the user
// is not using the default install. 99.999% chance it's the latter, so issue a warning
// should we ever hit the edge case.

// trim and remove trailing slash

// we want to read the CFBundleShortVersionString from Xcode's plist.
// It should be in /[root]/XCode.app/Contents/

// need to use string#match here; previous code used regexp#exec, which does not return null

// for ios 8 and up, the file extension for AutiomationInstrument changed.
// rather than waste time getting the iOSSDKVersion, just get both paths and see which one exists
//# sourceMappingURL=data:application/json;base64,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QUMvRDtTQUNGOzRDQUNNLFlBQVk7Ozs7Ozs7Q0FDcEI7O0FBRUQsU0FBUyxrQkFBa0IsR0FBSTs7O0FBRzdCLE1BQU0sUUFBUSxHQUFHLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSw4QkFBOEIsRUFDbkQsWUFBWSxDQUFDLENBQUM7O0FBRWhDLFVBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUs7QUFDdEIsUUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFO0FBQ1gsT0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLG9CQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUNqQztHQUNGLENBQUMsQ0FBQztDQUdKOztRQUVRLE9BQU8sR0FBUCxPQUFPO1FBQUUsVUFBVSxHQUFWLFVBQVU7UUFBRSw4QkFBOEIsR0FBOUIsOEJBQThCO1FBQUUsWUFBWSxHQUFaLFlBQVk7UUFDakUsMENBQTBDLEdBQTFDLDBDQUEwQztRQUFFLHdCQUF3QixHQUF4Qix3QkFBd0I7UUFDcEUsbUJBQW1CLEdBQW5CLG1CQUFtQjtRQUFFLGtCQUFrQixHQUFsQixrQkFBa0IiLCJmaWxlIjoibGliL3hjb2RlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5wbWxvZyBmcm9tICducG1sb2cnO1xuaW1wb3J0IHN1cHBvcnQgZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBkZW5vZGVpZnkgZnJvbSAnZGVub2RlaWZ5JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcmV0cnkgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBsaXN0IGZyb20gJ3BsaXN0JztcblxuY29uc3QgZXhlYyA9IHN1cHBvcnQuY29yZS5leGVjO1xuY29uc3QgdXRpbCA9IHN1cHBvcnQudXRpbDtcbmNvbnN0IGZpbGVFeGlzdHMgPSBzdXBwb3J0LnV0aWwuZmlsZUV4aXN0cztcbmNvbnN0IGVzY2FwZVNwYWNlID0gc3VwcG9ydC51dGlsLmVzY2FwZVNwYWNlO1xuY29uc3QgcmVhZFN5bWxpbmsgPSBkZW5vZGVpZnkoZnMucmVhZGxpbmspO1xuY29uc3QgZW52ID0gcHJvY2Vzcy5lbnY7XG5cbmNvbnN0IFhDT0RFX1NFTEVDVF9USU1FT1VUID0gMzAwMDtcbmNvbnN0IFhDT0RFX1NVQkRJUiA9IFwiL0NvbnRlbnRzL0RldmVsb3BlclwiO1xuY29uc3QgREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUyA9IDM7XG5cbmNvbnN0IGxvZyA9IHByb2Nlc3MuZW52LkdMT0JBTF9OUE1MT0cgPyBnbG9iYWwubG9nIDogbnBtbG9nO1xuXG5cbmZ1bmN0aW9uIGhhc0V4cGVjdGVkU3ViRGlyIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnN1YnN0cmluZyhwYXRoLmxlbmd0aCAtIFhDT0RFX1NVQkRJUi5sZW5ndGgpID09PSBYQ09ERV9TVUJESVI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tU3ltbGluayAoZmFpbE1lc3NhZ2UpIHtcbiAgLy8gTm9kZSdzIGludm9jYXRpb24gb2YgeGNvZGUtc2VsZWN0IHNvbWV0aW1lcyBmbGFrZXMgYW5kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAvLyBOb3QgY2xlYXIgd2h5LiBBcyBhIHdvcmthcm91bmQsIEFwcGl1bSBjYW4gcmVsaWFibHkgZGVkdWNlIHRoZSB2ZXJzaW9uIGluIHVzZSBieSBjaGVja2luZ1xuICAvLyB0aGUgbG9jYXRpb25zIHhjb2RlLXNlbGVjdCB1c2VzIHRvIHN0b3JlIHRoZSBzZWxlY3RlZCB2ZXJzaW9uJ3MgcGF0aC4gVGhpcyBzaG91bGQgYmUgMTAwJVxuICAvLyByZWxpYWJsZSBzbyBsb25nIGFzIHRoZSBsaW5rIGxvY2F0aW9ucyByZW1haW4gdGhlIHNhbWUuIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIHJlbHlpbmcgb25cbiAgLy8gaGFyZGNvZGVkIHBhdGhzLCB0aGlzIGFwcHJvYWNoIHdpbGwgYnJlYWsgdGhlIG5leHQgdGltZSBBcHBsZSBjaGFuZ2VzIHRoZSBzeW1saW5rIGxvY2F0aW9uLlxuICBsb2cud2FybihgRmluZGluZyBYY29kZVBhdGggYnkgc3ltbGluayBiZWNhdXNlICR7ZmFpbE1lc3NhZ2V9YCk7XG5cbiAgY29uc3Qgc3ltbGlua1BhdGggPSBcIi92YXIvZGIveGNvZGVfc2VsZWN0X2xpbmtcIjtcbiAgY29uc3QgbGVnYWN5U3ltbGlua1BhdGggPSBcIi91c3Ivc2hhcmUveGNvZGUtc2VsZWN0L3hjb2RlX2Rpcl9saW5rXCI7IC8vICBYY29kZSA8IDUueFxuICBsZXQgeGNvZGVQYXRoID0gbnVsbDtcblxuICAvLyB4Y29kZS1zZWxlY3QgYWxsb3dzIHVzZXJzIHRvIG92ZXJyaWRlIGl0cyBzZXR0aW5ncyB3aXRoIHRoZSBERVZFTE9QRVJfRElSIGVudiB2YXIsXG4gIC8vIHNvIGNoZWNrIHRoYXQgZmlyc3RcbiAgaWYgKHV0aWwuaGFzQ29udGVudChlbnYuREVWRUxPUEVSX0RJUikpIHtcbiAgICBjb25zdCBjdXN0b21QYXRoID0gaGFzRXhwZWN0ZWRTdWJEaXIoZW52LkRFVkVMT1BFUl9ESVIpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52LkRFVkVMT1BFUl9ESVIgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52LkRFVkVMT1BFUl9ESVIgKyBYQ09ERV9TVUJESVI7XG5cbiAgICBpZiAoYXdhaXQgZmlsZUV4aXN0cyhjdXN0b21QYXRoKSkge1xuICAgICAgeGNvZGVQYXRoID0gY3VzdG9tUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1lc2cgPSBgQ291bGQgbm90IGZpbmQgcGF0aCB0byBYY29kZSwgZW52aXJvbm1lbnQgdmFyaWFibGUgYCArXG4gICAgICAgICAgICAgICAgIGBERVZFTE9QRVJfRElSIHNldCB0bzogJHtlbnYuREVWRUxPUEVSX0RJUn0gYCArXG4gICAgICAgICAgICAgICAgIGBidXQgbm8gWGNvZGUgZm91bmRgO1xuICAgICAgbG9nLndhcm4obWVzZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGF3YWl0IGZpbGVFeGlzdHMoc3ltbGlua1BhdGgpKSB7XG4gICAgeGNvZGVQYXRoID0gcmVhZFN5bWxpbmsoc3ltbGlua1BhdGgpO1xuICB9IGVsc2UgaWYgKGF3YWl0IGZpbGVFeGlzdHMobGVnYWN5U3ltbGlua1BhdGgpKSB7XG4gICAgeGNvZGVQYXRoID0gcmVhZFN5bWxpbmsobGVnYWN5U3ltbGlua1BhdGgpO1xuICB9XG5cbiAgaWYgKHhjb2RlUGF0aCkge1xuICAgIHJldHVybiB4Y29kZVBhdGgucmVwbGFjZShuZXcgUmVnRXhwKFwiLyRcIiksIFwiXCIpLnRyaW0oKTtcbiAgfVxuXG4gIC8vIFdlIHNob3VsZCBvbmx5IGdldCBoZXJlIGlzIHdlIGZhaWxlZCB0byBjYXB0dXJlIHhjb2RlLXNlbGVjdCdzIHN0ZG91dCBhbmQgb3VyXG4gIC8vIG90aGVyIGNoZWNrcyBmYWlsZWQuIEVpdGhlciBBcHBsZSBoYXMgbW92ZWQgdGhlIHN5bWxpbmsgdG8gYSBuZXcgbG9jYXRpb24gb3IgdGhlIHVzZXJcbiAgLy8gaXMgbm90IHVzaW5nIHRoZSBkZWZhdWx0IGluc3RhbGwuIDk5Ljk5OSUgY2hhbmNlIGl0J3MgdGhlIGxhdHRlciwgc28gaXNzdWUgYSB3YXJuaW5nXG4gIC8vIHNob3VsZCB3ZSBldmVyIGhpdCB0aGUgZWRnZSBjYXNlLlxuICBsZXQgbXNnID0gYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gWGNvZGUgYnkgc3ltbGlua3MgbG9jYXRlZCBpbiAke3N5bWxpbmtQYXRofSwgb3IgJHtsZWdhY3lTeW1saW5rUGF0aH1gO1xuICBsb2cud2Fybihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcblxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRQYXRoRnJvbVhjb2RlU2VsZWN0ICgpIHtcblxuICBsZXQgW3N0ZG91dF0gPSBhd2FpdCBleGVjKCd4Y29kZS1zZWxlY3QgLS1wcmludC1wYXRoJywge21heEJ1ZmZlcjogNTI0Mjg4LCB0aW1lb3V0OiBYQ09ERV9TRUxFQ1RfVElNRU9VVH0pO1xuXG4gIC8vIHRyaW0gYW5kIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICBjb25zdCB4Y29kZUZvbGRlclBhdGggPSBzdGRvdXQucmVwbGFjZShuZXcgUmVnRXhwKFwiLyRcIiksIFwiXCIpLnRyaW0oKTtcblxuICBpZiAoIXV0aWwuaGFzQ29udGVudCh4Y29kZUZvbGRlclBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieGNvZGUtc2VsZWN0IHJldHVybmVkIGFuIGVtcHR5IHN0cmluZ1wiKTtcbiAgfVxuXG4gIGlmIChhd2FpdCBmaWxlRXhpc3RzKHhjb2RlRm9sZGVyUGF0aCkpIHtcbiAgICByZXR1cm4geGNvZGVGb2xkZXJQYXRoO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IGB4Y29kZS1zZWxlY3QgY291bGQgbm90IGZpbmQgeGNvZGUuIFBhdGg6ICR7eGNvZGVGb2xkZXJQYXRofSBkb2VzIG5vdCBleGlzdC5gO1xuICAgIGxvZy5lcnJvcihtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5cbmNvbnN0IGdldFBhdGggPSBfLm1lbW9pemUoZnVuY3Rpb24gKCkge1xuXG4gIC8vIGZpcnN0IHdlIHRyeSB1c2luZyB4Y29kZS1zZWxlY3QgdG8gZmluZCB0aGUgcGF0aFxuICAvLyB0aGVuIHdlIHRyeSB1c2luZyB0aGUgc3ltbGlua3MgdGhhdCBBcHBsZSBoYXMgYnkgZGVmYXVsdFxuXG4gIHJldHVybiBnZXRQYXRoRnJvbVhjb2RlU2VsZWN0KCkuY2F0Y2goZ2V0UGF0aEZyb21TeW1saW5rKTtcbn0pO1xuXG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSAoKSB7XG5cbiAgbGV0IHhjb2RlUGF0aCA9IGF3YWl0IGdldFBhdGgoKTtcblxuICAvLyB3ZSB3YW50IHRvIHJlYWQgdGhlIENGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nIGZyb20gWGNvZGUncyBwbGlzdC5cbiAgLy8gSXQgc2hvdWxkIGJlIGluIC9bcm9vdF0vWENvZGUuYXBwL0NvbnRlbnRzL1xuICBjb25zdCBwbGlzdFBhdGggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCBcIi4uXCIsIFwiSW5mby5wbGlzdFwiKTtcblxuICBpZiAoIWF3YWl0IGZpbGVFeGlzdHMocGxpc3RQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBYY29kZSB2ZXJzaW9uLiAke3BsaXN0UGF0aH0gZG9lcyBub3QgZXhpc3Qgb24gZGlzay5gKTtcbiAgfVxuXG4gIGNvbnN0IGNtZCA9IGAvdXNyL2xpYmV4ZWMvUGxpc3RCdWRkeSAtYyAnUHJpbnQgQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmcnICR7ZXNjYXBlU3BhY2UocGxpc3RQYXRoKX1gO1xuICBsZXQgW3N0ZG91dF0gPSBhd2FpdCBleGVjKGNtZCwge21heEJ1ZmZlcjogNTI0Mjg4LCB0aW1lb3V0OiBYQ09ERV9TRUxFQ1RfVElNRU9VVH0pO1xuXG4gIGxldCB2ZXJzaW9uUGF0dGVybiA9IC9cXGRcXC5cXGRcXC4qXFxkKi87XG4gIC8vIG5lZWQgdG8gdXNlIHN0cmluZyNtYXRjaCBoZXJlOyBwcmV2aW91cyBjb2RlIHVzZWQgcmVnZXhwI2V4ZWMsIHdoaWNoIGRvZXMgbm90IHJldHVybiBudWxsXG4gIGxldCBtYXRjaCA9IHN0ZG91dC5tYXRjaCh2ZXJzaW9uUGF0dGVybik7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCB8fCAhdXRpbC5oYXNDb250ZW50KG1hdGNoWzBdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIFhjb2RlIHZlcnNpb24uIHhjb2RlYnVpbGQgb3V0cHV0IHdhczogJHtzdGRvdXR9YCk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hbMF07XG59XG5cblxuY29uc3QgZ2V0VmVyc2lvbiA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTKSB7XG4gICAgcmV0dXJuIHJldHJ5KHJldHJpZXMsIGdldFZlcnNpb25XaXRob3V0UmV0cnkpO1xuICB9XG4pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnkgKCkge1xuXG4gIGNvbnN0IHhjb2RlUGF0aCA9IGF3YWl0IGdldFBhdGgoKTtcblxuICAvLyBmb3IgaW9zIDggYW5kIHVwLCB0aGUgZmlsZSBleHRlbnNpb24gZm9yIEF1dGlvbWF0aW9uSW5zdHJ1bWVudCBjaGFuZ2VkLlxuICAvLyByYXRoZXIgdGhhbiB3YXN0ZSB0aW1lIGdldHRpbmcgdGhlIGlPU1NES1ZlcnNpb24sIGp1c3QgZ2V0IGJvdGggcGF0aHMgYW5kIHNlZSB3aGljaCBvbmUgZXhpc3RzXG4gIGNvbnN0IGV4dGVuc2lvbnMgPSBbJ3hycGx1Z2luJywgJ2J1bmRsZSddO1xuICBjb25zdCBwYXRoUHJlZml4ID0gcGF0aC5yZXNvbHZlKHhjb2RlUGF0aCwgXCIuLi9BcHBsaWNhdGlvbnMvSW5zdHJ1bWVudHMuYXBwL0NvbnRlbnRzL1BsdWdJbnNcIik7XG4gIGNvbnN0IHBhdGhTdWZmaXggPSBcIkNvbnRlbnRzL1Jlc291cmNlcy9BdXRvbWF0aW9uLnRyYWNldGVtcGxhdGVcIjtcbiAgbGV0IGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHMgPSBbXG4gICAgcGF0aC5yZXNvbHZlKHBhdGhQcmVmaXgsIFwiQXV0b21hdGlvbkluc3RydW1lbnQuXCIgKyBleHRlbnNpb25zWzBdLCBwYXRoU3VmZml4KSxcbiAgICBwYXRoLnJlc29sdmUocGF0aFByZWZpeCwgXCJBdXRvbWF0aW9uSW5zdHJ1bWVudC5cIiArIGV4dGVuc2lvbnNbMV0sIHBhdGhTdWZmaXgpXG4gIF07XG5cbiAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoYXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoc1swXSkpIHtcbiAgICByZXR1cm4gYXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoc1swXTtcbiAgfVxuXG4gIGlmIChhd2FpdCBmaWxlRXhpc3RzKGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV0pKSB7XG4gICAgcmV0dXJuIGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV07XG4gIH1cblxuICBjb25zdCBtc2cgPSBcIkNvdWxkIG5vdCBmaW5kIEF1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSBpbiBhbnkgb2YgdGhlIGZvbGxvd2luZ1wiICtcbiAgICAgICAgICAgICAgYGxvY2F0aW9ucyAke2F1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHMudG9TdHJpbmcoKX1gO1xuICBsb2cuZXJyb3IobXNnKTtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cbn1cblxuY29uc3QgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoV2l0aG91dFJldHJ5KTtcbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5ICgpIHtcblxuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbigpO1xuXG4gIGlmICh2ZXJzaW9uWzBdID09PSAnNCcpIHtcbiAgICByZXR1cm4gJzYuMSc7XG4gIH1cblxuICBjb25zdCBjbWQgPSBgeGNydW4gLS1zZGsgaXBob25lc2ltdWxhdG9yIC0tc2hvdy1zZGstdmVyc2lvbmA7XG4gIGNvbnN0IFtzdGRvdXRdID0gYXdhaXQgZXhlYyhjbWQsIHttYXhCdWZmZXI6IDUyNDI4OCwgdGltZW91dDogWENPREVfU0VMRUNUX1RJTUVPVVR9KTtcblxuICBjb25zdCBzZGtWZXJzaW9uID0gc3Rkb3V0LnRyaW0oKTtcbiAgY29uc3QgbWF0Y2ggPSAvXFxkLlxcZC8uZXhlYyhzdGRvdXQpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHhjcnVuIHJldHVybmVkIGEgbm9uLW51bWVyaWMgaU9TIFNESyB2ZXJzaW9uOiAke3Nka1ZlcnNpb259YCk7XG4gIH1cblxuICByZXR1cm4gc2RrVmVyc2lvbjtcbn1cblxuY29uc3QgZ2V0TWF4SU9TU0RLID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5KTtcbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRGV2aWNlcyAoKSB7XG5cbiAgbGV0IFtzdGRvdXRdID0gYXdhaXQgZXhlYygnL3Vzci9zYmluL3N5c3RlbV9wcm9maWxlciAteG1sIFNQVVNCRGF0YVR5cGUnLFxuICAgIHttYXhCdWZmZXI6IDUyNDI4OCwgdGltZW91dDogWENPREVfU0VMRUNUX1RJTUVPVVR9KTtcbiAgbGV0IHBsaXN0Q29udGVudCA9IHBsaXN0LnBhcnNlKHN0ZG91dCk7XG5cbiAgbGV0IGRldmljZXNGb3VuZCA9IFtdO1xuICBsZXQgZW50cmllc1RvU2VhcmNoID0gW3BsaXN0Q29udGVudFswXV07XG4gIHdoaWxlIChlbnRyaWVzVG9TZWFyY2gubGVuZ3RoID4gMCkge1xuICAgIGxldCBjdXJyZW50RW50cnkgPSBlbnRyaWVzVG9TZWFyY2gucG9wKCk7XG4gICAgaWYgKGN1cnJlbnRFbnRyeSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBlbnRyaWVzVG9TZWFyY2ggPSBlbnRyaWVzVG9TZWFyY2guY29uY2F0KGN1cnJlbnRFbnRyeSk7XG4gICAgfSBlbHNlIGlmICgoY3VycmVudEVudHJ5Ll9uYW1lICYmXG4gICAgICAgICAgICAgICAgY3VycmVudEVudHJ5Ll9uYW1lLnN1YnN0cmluZygwLCA0KSA9PT0gXCJpUGFkXCIpIHx8XG4gICAgICAgICAgICAgICAoY3VycmVudEVudHJ5Ll9uYW1lICYmXG4gICAgICAgICAgICAgICAgY3VycmVudEVudHJ5Ll9uYW1lLnN1YnN0cmluZygwLCA2KSA9PT0gXCJpUGhvbmVcIikpIHtcbiAgICAgIGxldCBkZXZpY2VJbmZvID0ge1xuICAgICAgICBuYW1lOiBjdXJyZW50RW50cnkuX25hbWUsXG4gICAgICAgIHVkaWQ6IGN1cnJlbnRFbnRyeS5zZXJpYWxfbnVtLFxuICAgICAgICBwcm9kdWN0SWQ6IGN1cnJlbnRFbnRyeS5wcm9kdWN0X2lkLFxuICAgICAgICBkZXZpY2VWZXJzaW9uOiBjdXJyZW50RW50cnkuYmNkX2RldmljZVxuICAgICAgfTtcbiAgICAgIGRldmljZXNGb3VuZC5wdXNoKGRldmljZUluZm8pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEVudHJ5Ll9pdGVtcykge1xuICAgICAgZW50cmllc1RvU2VhcmNoID0gZW50cmllc1RvU2VhcmNoLmNvbmNhdChjdXJyZW50RW50cnkuX2l0ZW1zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRldmljZXNGb3VuZDtcbn1cblxuZnVuY3Rpb24gY2xlYXJJbnRlcm5hbENhY2hlICgpIHtcblxuICAvLyBtZW1vaXplZCBmdW5jdGlvbnNcbiAgY29uc3QgbWVtb2l6ZWQgPSBbZ2V0UGF0aCwgZ2V0VmVyc2lvbiwgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICBnZXRNYXhJT1NTREtdO1xuXG4gIG1lbW9pemVkLmZvckVhY2goKGYpID0+IHtcbiAgICBpZiAoZi5jYWNoZSkge1xuICAgICAgZi5jYWNoZSA9IG5ldyBfLm1lbW9pemUuQ2FjaGUoKTtcbiAgICB9XG4gIH0pO1xuXG5cbn1cblxuZXhwb3J0IHsgZ2V0UGF0aCwgZ2V0VmVyc2lvbiwgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoLCBnZXRNYXhJT1NTREssXG4gICAgICAgICBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnksIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSxcbiAgICAgICAgIGdldENvbm5lY3RlZERldmljZXMsIGNsZWFySW50ZXJuYWxDYWNoZSB9O1xuIl19